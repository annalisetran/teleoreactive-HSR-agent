%% Copyright 2017 Keith Clark, Peter Robinson
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permisions and
%% limitations under the License.

% A multi-task version of towerBuilder. The only changes are:
%  makeTower is declared as a tel_start procedure, meaning it can be called 
%  as the initial procedure of a task in a multi-tasking agent.
%
%  move_to_table and move_to_block are both declared as tel_atomic procs.
%   A task T must wait until the arm resource is free before entering either
%   procedure. The arm resource is released when T fires a rule in an earlier 
%   proc call that means that the entered atomic procedure is no longer active. 

%% To run:
%% Start the Python simulator in one terminal:
%% python oneArmSim.py
%% Start the Teleor interpreter in another terminal:
%% teleor -Atowers
%% In interpreter:
%% [oneArmTowerBuilders].
%% go().

%% See README for how to interact with simulator

def block ::= (1 .. 16)

tel_percept holding(block), on_table(block), on(block,block)        

tel_action pickup(block),  put_on_block(block), put_on_table()

%% To help in visualizing multi-task agents it is sometimes useful to
%% visualize the resources running tasks are using. We can do this by using
%% the system declared user defined resources_hook action.  If defined,
%% it is called each time the evaluator re-evaluates the tasks call stack.
%% Because we want to wrap the resource information for sending it
%% to the visualizer we need to declare a type for the possible messages.
def resources_message_ ::= locked_resources(term) | waiting_resources(term)
resources_hook() :: 
    get_active_resources(Resources) &
    get_waiting_resources(WResources) ~> 
        locked_resources(Resources) to oneArmSim ;
        waiting_resources(WResources) to oneArmSim  


rel stack(?list(block))  
% The  ? means list of labels may be given or generated     
stack([Block]) <= on_table(Block)
stack([Block1,Block2,..Blocks]) <=
    on(Block1,Block2) & stack([Block2,..Blocks])

rel tower(list(block))
tower([Block,..Blocks]) <= 
    not on(_,Block) & stack([Block,..Blocks])

rel clear(block)
clear(B) <= not on(_,B)


tel_start makeTower(list(block))    
makeTower(Blocks){
    tower(Blocks)  ~> () 

    stack(Blocks) & Blocks=[Block,..]  ~>
             unpile(Block) 
    
    Blocks=[Block1,Block2,..Rest] & tower([Block2,..Rest]) ~>
        move_to_block(Block1,Block2)  
    
    Blocks=[Block]   ~> move_to_table(Block) 
    
    Blocks = [_,..Rest] ~> makeTower(Rest) 
   
    }


tel unpile(block)  

unpile(Block){
    clear(Block)  ~> ()  
    
    on(OnBlock, Block) ~> 
        move_to_table(OnBlock)
    }
 

tel_atomic move_to_block(block, block) 
% Moves Block1 from wherever to be on Block2
move_to_block(Block1,Block2){   
    % In makeTower tasks will only be active if Block2 is clear    
    on(Block1,Block2) ~> ()         
    % The goal is achieved
    
    holding(Block1) ~> put_on_block(Block2)
    
    holding(_) ~> put_on_table()
    % Put any other held block directly on the table
    
    clear(Block1)  ~> pickup(Block1) 
    
    true ~> unpile(Block1)
    % Need to clear Block1 to pick it up   
    } 
 
tel_atomic move_to_table(block)
move_to_table(Block){
    on_table(Block) & not holding(_)~> ()  % Goal is achieved
    
    holding(_)  ~> put_on_table()
    
    clear(Block) ~> pickup(Block)
    
    true  ~> unpile(Block)
    }

rel being_used(list(block),?list(block))
being_used(Blocks,InUse) <= 
    InUse = [Block :: exists TBlocks (task(_,makeTower(TBlocks)) & 
                                      Block in TBlocks & Block in Blocks)]

def message ::=  
        newTower(list(block)) | kill(atom)

def msg_t_ ::= tel_started(atom, term) | 
        task_rejected(term, term) |
        task_killed(atom) |
        remove_task(atom) |
        in_use(term) |
        not_a_current_task(atom) |
        invalid(term)

handle_message(newTower(Blocks),Agent) :: 
    being_used(Blocks,[]) ~>
        start_task(makeTower(Blocks), T, makeTower); 
        task_data(T,Blocks) to oneArmSim;
        tel_started(T,makeTower(Blocks)) to Agent
handle_message(newTower(Blocks),Agent) :: 
    being_used(Blocks,InUse) ~>
        task_rejected(makeTower(Blocks),in_use(InUse)) to Agent
handle_message(kill(TaskName),Agent) :: 
    task(TaskName,_) ~>
        kill_task(TaskName);
        remove_task(TaskName) to oneArmSim;
        task_killed(TaskName) to Agent
handle_message(kill(TaskName),Agent)  ~>
    not_a_current_task(TaskName) to Agent

handle_invalid_message(Message,Agent)  ~>  
    invalid(Message) to Agent

def task_desc ::= task_data(atom, list(block)) 

act go1()
go1() ~>
    start_agent(oneArmSim, updates);
    task_data(t1, [2,5,9,6]) to oneArmSim;
    start_task(makeTower([2,5,9,6]), _, t)

act go2()
go2() ~>
    start_task(makeTower([12,15,8,1]), T1, t);
    task_data(T1, [12,15,8,1]) to oneArmSim;
    start_task(makeTower([14,13,7,16]), T2, t);
    task_data(T2, [14,13,7,16]) to oneArmSim

act go()
go() :: 
    Tasks = [task_data(t1, [2,5,9,6]),
             task_data(t2, [12,15,8,1]),
             task_data(t3, [14,13,7,16])] 
            ~> 
            start_agent(oneArmSim, updates);
            forall T {T in Tasks ~> T to oneArmSim} ; 
            forall Task,Tower {
                    task_data(Task, Tower) in Tasks  ~>
                        start_named_task(makeTower(Tower), Task)}
            


