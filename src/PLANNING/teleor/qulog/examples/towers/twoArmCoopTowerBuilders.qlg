%% Copyright 2017 Keith Clark, Peter Robinson
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permisions and
%% limitations under the License.

%% A multi-task tower builder with 2 arms and 3 tables.
%% Like twoArmTowerBuilders.qlg but unpile is replaced
%% with a cooperative version. This is also similar to
%% oneArmCoopTowerBuilders.qlg but cooperation is more involved because
%% cooperation can involve moving an unwanted block to, for example,
%% the shared table so that a task building a tower on the other table can
%% later access this block using just one arm.
%% One major difference to twoArmTowerBuilders.qlg is we use 
%% commit_while when unpiling so that we (mostly) commit to completing a 
%% cooperative move of a block before firing a different rule. 

% To run:
% In one terminal:
% python twoArmSim.py
% In another terminal:
% teleor -Atowers
% In interpreter:
% [twoArmCoopTowerBuilders].
% go().

% In the simulation press the space bar and then drag blocks around - press
% the space again to continue.

def arm ::= arm1 | arm2
def table ::= table1 | shared | table2
def block ::= (1 .. 16)

def loc == table || block

fun other(arm) -> arm
other(arm1) -> arm2
other(arm2) -> arm1

tel_percept holding(arm, block), on(block, block), 
    on_table(block,table), over_home(arm), tracking(arm)

tel_action pickup(arm, block, table), put_on_table(arm, table), 
        put_on_block(arm,block,table) 

def resource ==  arm || table

def resources_message_ ::= locked_resources(term) | waiting_resources(term)

resources_hook() :: 
    get_active_resources(Resources) &
    get_waiting_resources(WResources)
        ~> 
            locked_resources(Resources) to twoArmSim ;
            waiting_resources(WResources) to  twoArmSim
% Called by evaluator, when defined, to send info to the simulator

rel tower(list(block), ?table) 
tower([B,..Bs],Tbl) <= not on(_,B) & stack([B,..Bs],Tbl)

rel clear(block)
clear(B) <= not holding(_,B) & not on(_,B)

rel stack(?list(block),?table)
stack([B], T) :: on_table(B,T) 
stack([B1,B2|Bs], T) :: on(B1, B2) & stack([B2|Bs], T)

fun home_table(arm) -> table
home_table(arm1) -> table1
home_table(arm2) -> table2

fun other_arm(arm) -> arm
other_arm(arm1) -> arm2
other_arm(arm2) -> arm1

rel can_reach_block(arm,block,?table)     
can_reach_block(Arm,Block,Tab) <=      
    somewhere_on(Block,Tab) & can_reach_table(Arm,Tab) 

rel can_reach_table(arm,?table)
can_reach_table(_Arm,shared)
can_reach_table(Arm,Tab) <= Tab=home_table(Arm)  


rel somewhere_on(block,?table)     
somewhere_on(Block,Tab) :: on_table(Block,Tab)
somewhere_on(Block,Tab) <=
    on(Block,BellowBlock) & somewhere_on(BellowBlock,Tab)

tel_start makeTower(arm,list(block),table)
makeTower(Arm,Blocks,TowerTab){
    tower(Blocks,TowerTab) ~> ()   
    
    stack(Blocks,TowerTab) & 
    Blocks = [Block,.._Rest] 
        commit_while holding(Arm,_) ~>                   
                unpile_C(Arm,Block,TowerTab,TowerTab)   
    
    Blocks = [Block, TopBlock,..Rest] & 
    tower([TopBlock,..Rest],TowerTab) ~> 
        move_across_to_block(Arm,Block,TopBlock,TowerTab)  
    
    Blocks=[Block] ~> 
        move_across_to_table(Arm,Block,TowerTab)      
    
    Blocks = [_,..Rest] ~> makeTower(Arm,Rest,TowerTab)
    }

tel unpile_C(arm,block,table,table)
unpile_C(Arm,Block,BlockTab,ToTab){
    % All calls to unpile_C are in commit_while holding rules
    % This, together with use of commit_while holding in all the move 
    % rules of this procedure, ensures that it remains active until last
    % block covering Block has been put down by Arm.
    % Any block above Block that is needed for the tower of another task
    % is putdown in a location that helps that other task: 
    clear(Block)  ~> () 
    
    on(OnBlock,Block) & ToTab\=shared &                        
    needed_by_task_using(OnBlock,ToTab,Loc) 
    % Loc is location to which OnBlock should be moved to help another task T
    % building a tower on ToTab. Loc is either ToTab, or the block currently at
    % the top T's partly built  tower on ToTab when Block needed as the next
    % block 
        commit_while holding(Arm,OnBlock) ~>  
                move_to_location(Arm,OnBlock,BlockTab,Loc,ToTab) 
    
    on(OnBlock,Block) & BlockTab \= shared & 
    % Same comment as for above rule except tower is being built on BlockTab
    needed_by_task_using(OnBlock,BlockTab,Loc) 
        commit_while holding(Arm,OnBlock)  ~>
                move_to_location(Arm,OnBlock,BlockTab,Loc,BlockTab) 

    on(OnBlock,Block) & ToTab=shared & 
    needed_by_task_using(OnBlock,home_table(other_arm(Arm)),_) 
    % Help task needing OnBlock building on home table of the other arm
    % by moving OnBlock to ToTab when this is shared table.
        commit_while holding(Arm,OnBlock) ~>  
                move_to_table(Arm,OnBlock,BlockTab,ToTab) 
    
    
    on(OnBlock,Block) % & clear(OnBlock)  
        commit_while holding(Arm,OnBlock) ~>  
                move_to_table(Arm,OnBlock,BlockTab,BlockTab)
    % OnBlock not needed by a task that can be helped by placing it
    % on a partial tower or directly on a table other than BlockTab. 
    } 

tel_atomic move_to_block(arm,block,table,block,table)
move_to_block(Arm,Block,BlockTab,ToBlock,TowerTab){
    % Procedure will only be called when Block somewhere on BlockTab 
    % or held by Arm. Only active while ToBlock clear, somewhere on TowerTab
    on(Block,ToBlock) ~> ()
    
    holding(Arm,Block) ~> 
        put_on_block(Arm,ToBlock,TowerTab)
    
    clear(Block) & not holding(Arm,_) ~> 
        pickup(Arm,Block,BlockTab)
    
    on(_,Block) & not holding(Arm,_)
        commit_while holding(Arm,_) ~> 
                unpile_C(Arm,Block,BlockTab,TowerTab)  
    
    holding(Arm,OtherBlock) & 
    needed_by_task_using(OtherBlock,TowerTab,Loc) ~>
        put_on_location(Arm,TowerTab,Loc)
    
    holding(Arm,_) ~> put_on_table(Arm,BlockTab)     
    } 


tel put_on_location(arm,table,loc)
put_on_location(Arm,Table,Loc){
    Loc = Table ~> put_on_table(Arm,Table)
    type(Loc,block) ~> put_on_block(Arm,Loc,Table)
    }

tel_atomic move_to_table(arm,block,table,table)
move_to_table(Arm,Block,BlockTab,ToTab){
    % Procedure will only be called when Block somewhere 
    % on BlockTab or held by Arm
    on_table(Block,ToTab) ~> ()
    
    holding(Arm,Block) ~> 
        put_on_table(Arm,ToTab)
    
    clear(Block) & not holding(Arm,_)  ~> 
        pickup(Arm,Block,BlockTab)
    
    on(_,Block) & not holding(Arm,_) 
        commit_while holding(Arm,_) ~> 
                unpile_C(Arm,Block,BlockTab,ToTab)  
    
    holding(Arm,OtherBlock) & 
    needed_by_task_using(OtherBlock,ToTab,Loc) ~> 
        put_on_location(Arm,ToTab,Loc)
    
    holding(Arm,_) ~> 
        put_on_table(Arm,BlockTab)
    } 



tel move_across_to_table(arm,block,table)
move_across_to_table(Arm,Block,ToTab){
    on_table(Block,ToTab) ~> ()
    
    can_reach_block(Arm,Block,BlockTab) 
        or_while holding(Arm,Block) ~>
                move_to_table(Arm,Block,BlockTab,ToTab)
    
    holding(Arm,Block) ~> 
        move_to_table(Arm,Block,ToTab,ToTab)
    
    OtherArm=other(Arm) & on_home_table_or_holding(OtherArm,Block) ~>
        move_to_table(OtherArm,Block,home_table(OtherArm),shared)
        % Move it to shared table to be reachable by Arm
    }

rel on_home_table_or_holding(arm,block)
on_home_table_or_holding(Arm,Block) <= 
    somewhere_on(Block,home_table(Arm))
on_home_table_or_holding(Arm,Block) <= 
    holding(Arm,Block)

tel move_across_to_block(arm,block,block,table)
move_across_to_block(Arm,Block,ToBlock,TowerTab){
    % Will only be active whilst ToBlock is on TowerTab and clear
    on(Block,ToBlock) ~> ()
    
    can_reach_block(Arm,Block,BlockTab) 
        or_while holding(Arm,Block) ~> 
                move_to_block(Arm,Block,BlockTab,ToBlock,TowerTab)
    
    holding(Arm,Block) ~> 
        move_to_block(Arm,Block,TowerTab,ToBlock,TowerTab)
    
    OtherArm=other(Arm) & on_home_table_or_holding(OtherArm,Block) ~>
        move_to_table(OtherArm,Block,home_table(OtherArm),shared)
    % Move it to shared table so as to be reachable by Arm
    }


fun other_table(table) -> table
other_table(table1) -> table2
other_table(table2) -> table1


rel needed_by_task_using(block,table,?loc)
needed_by_task_using(OnBlock,Tab,Loc) <=
    % Another task can be helped putting OnBlock on Loc on Tab
    task(_,makeTower(_,BlocksList,Tab)) &
    BlocksList =? _ <> [OnBlock] <> Blocks &
    % The above splits BlockList at OnBlock if this block is on BlockList
    % with Blocks the sub-list below Block. It fails if Block not on BlockList
    Loc = location_for_the_removed_block(Blocks,Tab)
    % Makes Loc the top block of Blocks if Blocks is a tower, else Loc=Tab  

fun location_for_the_removed_block(list(block),table) -> loc
location_for_the_removed_block([TopBlock,..MoreBlocks],Tab) ::
      tower([TopBlock,..MoreBlocks],Tab) -> TopBlock
location_for_the_removed_block(_,Tab) -> Tab

tel move_to_location(arm,block,table,loc,table)
move_to_location(Arm,OnBlock,BlockTab,Loc,ToTab){
    Loc=ToTab ~> 
        move_to_table(Arm,OnBlock,BlockTab,ToTab)
    type(Loc,block) ~> 
        move_to_block(Arm,OnBlock,BlockTab,Loc,ToTab)
    }

def task_desc ::= task_data(atom, arm, list(block), table)

act go()
go() :: Tasks = [task_data(t1, arm1, [2,5,9,6], table1),
                 task_data(t2, arm1, [3,4,10,7], table1),
                 task_data(t3, arm2, [1,8,11,15], table2)]
        ~>
        start_agent(twoArmSim@localhost, updates);
        forall TDescr 
               {TDescr in Tasks ~> TDescr to twoArmSim} ; 
        forall T,Arm, Tower,Table 
               {task_data(T, Arm, Tower, Table) in Tasks  ~>
                    start_named_task(makeTower(Arm, Tower, Table), T)
                    }
        
