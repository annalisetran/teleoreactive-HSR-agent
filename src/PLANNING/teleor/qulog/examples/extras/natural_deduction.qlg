
/*
 * A natural deduction prover for propositional logic
 * Based on the Qu-Prolog example
 */

%%%%%%%%%%%%%
% User declared predicates

def predicate ::= gs(formula_term) | ent(formula_term) |
        mem(formula_term) | acc(formula_term, formula_term) |
        fior(formula_term)

def formula_objvar ::= x | y
%%%%%%%%%%%%%%

% formula declaration - true, false and p,q etc are formulas
% the logical connectives are compound formulas

def formula == compound_formula || predicate || atom

def formula_var ::= var(string)
def skolem ::= sk(int, list(formula_term))
def formula_term == formula_objvar || formula_var || skolem 

def compound_formula ::=
        and(formula, formula) |
        or(formula, formula) |
        imp(formula, formula) |
        ~(formula) |
        all(formula_objvar, formula) |
        ex(formula_objvar, formula)

%% skolem_id

int skolem_id := 1



% Declaring sequents - e.g.  p, q |- p
def sequent ::= |-(list(formula), formula)

% declaring rules - init_proof is a special name used for the proof start
def rule_name ==
        init_proof_name || atomic_rule_name || compound_rule_name

def init_proof_name ::= init_proof

def atomic_rule_name ::=
        and_i |
        or_i1 |
        or_i2 |
        imp_i |
        neg_i |
        false_i |
        discharge_any |
        and_e_any |
        or_e_any |        
        imp_e_any |        
        neg_e_any |
        or_i_any |
        ex_i | 
        all_i

% the argument is the index of the hypothesis
def compound_rule_name ::=
        discharge(nat) |
        and_e(nat) |
        or_e(nat) |        
        imp_e(nat) |        
        neg_e(nat) |
        all_e(nat) |
        all_e2(nat) |
        ex_e(nat)

% by giving an enumerated type for the rules for the auto tactic
% we can use isa(T, auto_rules) to backtrack over possible rules
def auto_rules ::=
        discharge_any |
        and_i |
        imp_i |
        neg_i |
        and_e_any |
        or_e_any |        
        imp_e_any |        
        neg_e_any |
        or_i_any 

% a proof step is used to encode a step in the proof so that the
% complete proof can be listed at the completion of the proof
def proof_step ::= ps(rule_name, list(sequent))

% All steps in the proof are done via tactics which typically adds
% to list (stack) of proof steps. The first element encodes the current 
% state of the proof
def tactic == rel(!list(proof_step), ?list(proof_step))

fun trans(rule_name) -> tactic
trans(discharge_any)(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(discharge(N), P1, Ps) &
        Q = [ps(discharge(N), Ps <> Rest),..P]
trans(and_e_any)(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(and_e(N), P1, Ps) &
        Q = [ps(and_e(N), Ps <> Rest),..P]
trans(and_e(N))(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(and_e(N), P1, Ps) &
        Q = [ps(and_e(N), Ps <> Rest),..P]
trans(or_e_any)(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(or_e(N), P1, Ps) &
        Q = [ps(or_e(N), Ps <> Rest),..P]
trans(or_e(N))(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(or_e(N), P1, Ps) &
        Q = [ps(or_e(N), Ps <> Rest),..P]
trans(imp_e_any)(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(imp_e(N), P1, Ps) &
        Q = [ps(imp_e(N), Ps <> Rest),..P]
trans(imp_e(N))(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(imp_e(N), P1, Ps) &
        Q = [ps(imp_e(N), Ps <> Rest),..P]
trans(neg_e_any)(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(neg_e(N), P1, Ps) &
        Q = [ps(neg_e(N), Ps <> Rest),..P]
trans(neg_e(N))(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(neg_e(N), P1, Ps) &
        Q = [ps(neg_e(N), Ps <> Rest),..P]
trans(or_i_any)(P, Q) <=
    P = [ps(_, [P1,..Rest]),..] &
    rule(or_i1, P1, Ps) &
    Q = [ps(or_i1, Ps <> Rest),..P]
trans(or_i_any)(P, Q) :: true <=
        P = [ps(_, [P1,..Rest]),..] &
        rule(or_i2, P1, Ps) &
        Q = [ps(or_i2, Ps <> Rest),..P]
trans(Rule)(P, Q) <=
    P = [ps(_, [P1,..Rest]),..] &
    rule(Rule, P1, Ps) &
    Q = [ps(Rule, Ps <> Rest),..P]

% a special tactic that simply tests if the proof is finished
rel finished(!list(proof_step), ?list(proof_step))
finished(Steps, Steps) <= Steps = [ps(_,[]),..]

% the auto tatic that attempts to complete a proof automatically
rel auto(!list(proof_step), ?list(proof_step))
auto(P, Q) <=
    isa(T, auto_rules) &
    Tac = trans(T) &
    Tac(P, P1) &
    P1 = [ps(_, State),..] &    
    {write_list(["Applying ", Tac, nl_, #P1, ":", nl_]);display_state(State)} &
    auto(P1, Q)
auto(P,P) <=
    finished(P, _)

% The encoding of the sequent calculus rules
rel rule(?rule_name,  !sequent, ?list(sequent))

rule(discharge(N), |-(Gamma, P), []) <= 
    transform_subterms(varstr2var, P, PX) &
    nth_item(N, A, Gamma) &
    transform_subterms(varstr2var, A, AX) &
    AX = PX
rule(and_i, |-(Gamma, and(A, B)), [|-(Gamma, A), |-(Gamma, B)])
rule(or_i1, |-(Gamma, or(A, _B)), [|-(Gamma, A)])
rule(or_i2, |-(Gamma, or(_A, B)), [|-(Gamma, B)])
rule(imp_i, |-(Gamma, imp(A, B)), [|-([A|Gamma], B)])
rule(neg_i, |-(Gamma, ~(A)) , [|-([A|Gamma], false)])
rule(false_i, |-(Gamma, _A), [|-(Gamma, false)])
rule(and_e(N), |-(Gamma, C), [|-([A,B|NewGamma], C)]) <= 
    nth_and_rest(N, and(A, B), Gamma, NewGamma)
rule(imp_e(N), |-(Gamma, C), [|-(NewGamma, A), |-([B|NewGamma], C)]) <=
    nth_and_rest(N, imp(A, B), Gamma, NewGamma).
rule(or_e(N), |-(Gamma, C), [|-([A|NewGamma], C), 
                               |-([B|NewGamma], C)]) <=        
    nth_and_rest(N, or(A,B), Gamma, NewGamma)
rule(neg_e(N), |-(Gamma, C), [|-(NewGamma, A), 
                                |-([false|NewGamma], C)]) <=
    nth_and_rest(N, ~(A), Gamma, NewGamma)

rule(ex_i, |-(Gamma, ex(X, A)), [|-(Gamma,AX)]) <=
    term2string(_, V) &
    transform_subterms(obvar_var(X, var(V)), A, AX1) &
    type(AX1, formula) & AX = AX1
rule(all_e(N), |-(Gamma, C), [|-([AX|NewGamma], C)]) <=
    nth_and_rest(N, all(X, A), Gamma, NewGamma) &
    term2string(_, V) &
    transform_subterms(obvar_var(X, var(V)), A, AX1) &
    type(AX1, formula) & AX = AX1
rule(all_e2(N), |-(Gamma, C), [|-([AX|Gamma], C)]) <=
    nth_item(N, all(X, A), Gamma) &
    term2string(_, V) &
    transform_subterms(obvar_var(X, var(V)), A, AX1) &
    type(AX1, formula) & AX = AX1
rule(all_i, |-(Gamma, all(X, A)), [|-(Gamma,AX)]) <=
    make_skolem_symbol([Gamma, A], Sk) &
    transform_subterms(obvar_var(X, Sk), A, AX1) &
    type(AX1, formula) & AX = AX1
rule(ex_e(N), |-(Gamma, C), [|-([AX|NewGamma], C)]) <=
    nth_and_rest(N, ex(X, A), Gamma, NewGamma) &
    make_skolem_symbol([Gamma, A, C], Sk) &
    transform_subterms(obvar_var(X, Sk), A, AX1) &
    type(AX1, formula) & AX = AX1
        

rel make_skolem_symbol(term, ?skolem)

make_skolem_symbol(T, Sk) <=
    %transform_subterms(strip_var, T, ST) &
    collect_simple_terms(collect_vars, T, [], TV) &
    type(TV, list(term)) &
    sort(TV, STV, @<) &
    type(STV, list(formula_term)) & 
    Sk = sk($skolem_id, STV) &
    { skolem_id +:= 1 }


% nth_item(N, A, Fs) is true if A is the N'th element of Fs
% We can give N or have the code choose both N and A.
rel nth_item(?nat, ?formula, !list(formula))
nth_item(1, A, [A|_])
nth_item(N, A, [_|T]) <= nth_item(M, A, T) & N = M + 1

% the same as above except the chosen formula is removed from the
% input list of formula
rel nth_and_rest(?nat, ?formula, !list(formula), ?list(formula))
nth_and_rest(1, A, [A|T], T)
nth_and_rest(N, A, [H|T], [H|NT]) <=
    nth_and_rest(M, A, T, NT) & N = M + 1


% Used to display the outcome of the proof
% completed : the proof has been successfully completed
% abandoned : the user entered 'quit' to abandoned the proof
% failed : no proof was found
def status ::= completed | abandoned | failed

% start a proof
act do_proof(), do_sequent_proof()

do_proof() ~>
    repeat { % keep asking the user for formula until a valid formula is entered
        write_list(["Enter formula to prove: "]);
        flush_output();
        get_line(Str);
        write_list([nl_]);
        ?(string2formula(Str, Formula))
        } until Formula \= no_formula;
    ?(start_proof(Formula, Status));  % do the proof
    show_status(Status)

do_sequent_proof() ~>
    get_antecedents(Ante);
    repeat { 
        write_list(["Enter conclusion: "]);
        flush_output();
        get_line(Str);
        write_list([nl_]);
        ?(string2formula(Str, Formula))
        } until Formula \= no_formula;
    ?(start_sequent_proof(Ante, Formula, Status));  % do the proof
    show_status(Status)
    
act get_antecedents( ?list(formula))
get_antecedents(Ante) ~>
    repeat {
        write_list(["Enter antecedent (RETURN to terminate): "]);
        flush_output();
        get_line(Str);
        ?(string2formula(Str, Formula))
        } until Formula \= no_formula;
    case {
        Formula = empty_formula & Ante = [] ~> {}
        
        Ante = [Formula,..Rest] ~> 
            get_antecedents(Rest)
        }

        
    
act show_status(status)
show_status(completed) ~> {}
show_status(Status) ~>
    write_list(["Proof ", Status, nl_])


       
        
rel start_proof(formula, ?status)
start_proof(Formula, Status) ::
    interact_proof([ps(init_proof, [|-([], Formula)])], 1,  Status)
start_proof(_, failed) 

rel start_sequent_proof(list(formula), formula, ?status)
start_sequent_proof(Ante, Formula, Status) ::
    interact_proof([ps(init_proof, [|-(Ante, Formula)])], 1,  Status)
start_sequent_proof(_, _, failed)



rel interact_proof(list(proof_step), int, ?status)
interact_proof(Steps, _, Status) :: 
    Steps = [ps(_, []),..] &    % the proof has sucessfully completed
    Status = completed &
    {write_proof(Steps)}
interact_proof(Sequents, Level, Status) <=
    {get_command(Sequents, Level, Cmd)} &  % apply a step
    interact_proof_step(Cmd, Sequents, Level, Status)

% doing a proof step
rel interact_proof_step(!term_naming(tactic),list(proof_step), int, ?status)
% abandon the proof
interact_proof_step(quit, _, _, Status) :: true <= Status = abandoned
% undo (fail) the previous step(s)
interact_proof_step(undo, _, _, _) :: true <= false
% apply a rule
interact_proof_step(Tactic, Sequents, Level, Status) <=
    Tactic(Sequents, NewSequents) &
    backtracking_message(Tactic) &
    interact_proof(NewSequents, Level + 1, Status)
% the tactic failed or backtracking over previous tactic failed
interact_proof_step(Tactic, Sequents, Level, Status) <=
    {write_list([Tactic, " failed ", nl_])} &
    interact_proof(Sequents, Level, Status)

% display a retry message then fail
rel backtracking_message(term_naming(tactic))
backtracking_message(_)
backtracking_message(Tactic) <= 
    {write_list(["Retrying ", Tactic, nl_])} & false

% special tactics
rel quit(!list(proof_step), ?list(proof_step))
rel undo(!list(proof_step), ?list(proof_step))
rel not_a_tactic(!list(proof_step), ?list(proof_step))
    
act display_state(list(sequent))
display_state(Sequents) :: sequentlist2string(Sequents, Str) ~>
        put_line(Str)       


% get a tactic from the user - keep trying until valid tactic entered
act get_command(list(proof_step), int, ?term_naming(tactic))
get_command([ps(_, Sequents),..], Level, Cmd) ~>
    repeat {
        write_list([Level, ":", nl_]);
        display_state(Sequents);
        write_list([nl_, "Command: "]);
        flush_output();
        get_line(CmdStr);
        case {
            CmdStr = "\n" & Cmd = not_a_tactic ~> {}
            
            true ~>
                try {
                    string2tactic(CmdStr, Cmd)
                    } 
                except {
                    string2term_syntax_error(_) ~>
                        write_list(["Syntax error", nl_]);
                        ?(Cmd = not_a_tactic)
                    string2term_type_error(_) ~>
                        write_list(["Type error", nl_]);
                        ?(Cmd = not_a_tactic)
                    } 
            }
            
        } until Cmd \= not_a_tactic

act string2tactic(string, ?term_naming(tactic))
string2tactic(CmdStr, Cmd) :: 
    string2term(CmdStr, Cmd1) &
    type(Cmd1, !term_naming(tactic)) &
    Cmd = Cmd1 ~> {}
string2tactic(CmdStr, _) ~> raise(string2term_type_error(CmdStr))

%% Parsing and pretty printing

act write_proof(list(proof_step))

write_proof([]) ~> write_list(["Proof Completed\nProof:", nl_])
write_proof([ps(init_proof, Preds),..Rest]) ~>
    write_proof(Rest);
    write_list(["Statement "]);
    ?(sequentlist2string(Preds, PredString));
    write_list([PredString])
write_proof([ps(Rule, Preds),..Rest]) ~>
    write_proof(Rest);
    write_list(["-------------\nApply ", Rule,nl_]);
    ?(sequentlist2string(Preds, PredString));
    write_list([PredString])

rel string2list_formula(string, list(formula))
rel string2sequent(string, sequent)

rel tokenize_formula(string, ?list(string))

tokenize_formula("", []) :: true
tokenize_formula(Str, Tokens) ::
    Str =? _Whites/"(\\s+)" ++ Rest <=
        tokenize_formula(Rest, Tokens)
tokenize_formula(Str, []) ::
    Str =? "." ++ _ 
tokenize_formula(Str, ["("|Tokens]) ::
    Str =? "(" ++ Rest <=
        tokenize_formula(Rest, Tokens)
tokenize_formula(Str, [")"|Tokens]) ::
    Str =? ")" ++ Rest <=
        tokenize_formula(Rest, Tokens)
tokenize_formula(Str, ["=>"|Tokens]) ::
    Str =? "=>" ++ Rest <=
        tokenize_formula(Rest, Tokens)
tokenize_formula(Str, ["~"|Tokens]) ::
    Str =? "~" ++ Rest <=
        tokenize_formula(Rest, Tokens)
tokenize_formula(Str, [","|Tokens]) ::
    Str =? "," ++ Rest & tokenize_formula(Rest, Tokens)
tokenize_formula(Str, [T|Tokens]) <=
    Str =? T/"\\w*" ++ Rest & tokenize_formula(Rest, Tokens)

rel string2formula(string, ?formula)
string2formula("\n", empty_formula) :: true
string2formula(Str, Formula) ::
    tokenize_formula(Str, Tokens) &
    parse(Tokens, [], Formula)
string2formula(_Str, no_formula) <= {put_line("Can't parse formula")} 

rel parse(!list(string), ?list(string), ?formula)

parse(Tokens, Rest, Formula) <=
    parse_atomic(Tokens, RestTokens, Atomic) &
    parse_aux(RestTokens, Atomic, Rest, Formula)

rel parse_aux(!list(string), !formula, ?list(string), ?formula)

parse_aux([], F, [], F)
parse_aux([Op|Tokens], Atomic1, Rest, Formula) <=
    op(Op) &
    parse_atomic(Tokens, RestTokens, Atomic2) &
    parse_rest(RestTokens, Atomic1, Op, Atomic2, Rest, Formula)

rel parse_rest(list(string), formula, string, formula, ?list(string), ?formula)
        

parse_rest([Op|Tokens], Formula1, PrevOp, Formula2, Rest, Formula) :: 
    op(Op) &  lower_precedence(Op, PrevOp) <=
        construct_formula(PrevOp, Formula1, Formula2, Formula3) &
        parse_atomic(Tokens, RestTokens, Atomic) &
        parse_rest(RestTokens,  Formula3, Op, Atomic, Rest, Formula)
parse_rest([Op|Tokens], Formula1, PrevOp, Formula2, Rest, Formula) :: 
    op(Op) <=
        parse_atomic(Tokens, RestTokens, Atomic) &
        parse_rest(RestTokens, Formula2, Op, Atomic, Rest, Formula3) &
        construct_formula(PrevOp, Formula1, Formula3, Formula)
parse_rest(Tokens, Formula1, Op, Formula2, Tokens, Formula) <=
    construct_formula(Op, Formula1, Formula2, Formula)

rel parse_atomic(list(string), ?list(string), ?formula)
parse_atomic(["("|Tokens], Left, Formula) :: true <=
        parse(Tokens, LeftTokens, Formula) &
        LeftTokens = [")"|Left]
parse_atomic(["~", "("|Tokens], Left, ~(Formula)) :: true <=
        parse(Tokens, LeftTokens, Formula) &
        LeftTokens = [")"|Left]
parse_atomic(["~"|Tokens], Left, ~(P)) :: true <=
        parse_atomic(Tokens, Left, P)
parse_atomic(["all", OvToken|Tokens], Left, all(Ov, Body)) :: true <=
        string2term(OvToken, O) & type(O, formula_objvar) & Ov = O &
        parse_atomic(Tokens, Left, Body)
parse_atomic(["ex", OvToken|Tokens], Left, ex(Ov, Body)) :: true <=
        string2term(OvToken, O) & type(O, formula_objvar) & Ov = O &
        parse_atomic(Tokens, Left, Body)
parse_atomic([F, "("|Tokens], Left, Compound) :: 
    Tokens =? Body <> [")"] <> Left <=
        string2term( F ++ "(" ++ strlist2str(Body) ++ ")", C) &
        type(C, formula) & Compound = C
parse_atomic([T|Tokens], Tokens, P) :: true <=
        string2term(T, P1) & type(P1, formula) & P = P1



% parse_atomic(["("|Tokens], Left, Formula) :: true <=
%         parse(Tokens, LeftTokens, Formula) &
%         LeftTokens = [")"|Left]
% parse_atomic(["~", "("|Tokens], Left, ~(Formula)) :: true <=
%         parse(Tokens, LeftTokens, Formula) &
%         LeftTokens = [")"|Left]
% parse_atomic(["~", T|Tokens], Tokens, ~(P)) :: true <=
%         string2term(T, P1) & type(P1, !atom) & P = P1
% parse_atomic([T|Tokens], Tokens, P) :: true <=
%         string2term(T, P1) & type(P1, !atom) & P = P1


fun strlist2str(list(string)) -> string
strlist2str([]) -> ""
strlist2str([S|Rest]) -> S ++  strlist2str(Rest)




rel construct_formula(string, formula, formula, ?formula)
construct_formula("=>", F1, F2, imp(F1, F2))
construct_formula("or", F1, F2, or(F1, F2))
construct_formula("and", F1, F2, and(F1, F2))

rel op(!string)
op("and")
op("or")
op("=>")

rel lower_precedence(string, string)
lower_precedence("=>", "and") :: true
lower_precedence("=>", "or") :: true
lower_precedence("or", "and") :: true



rel sequentlist2string(!list(sequent), ?string)
rel sequent2string(!sequent, ?string)

sequentlist2string([], "")
sequentlist2string([|-(H, C)|Sequents] , Str) <=
    formula_list2string(H, HStr) &
    formula2string(C, none, CStr) &
    sequentlist2string(Sequents, SequentsStr) &
    Str = HStr ++ "\n|- " ++ CStr ++ "\n----------\n" ++ SequentsStr

rel formula_list2string (!list(formula), ?string)

formula_list2string([], "")
formula_list2string([F], Str) :: true <= formula2string(F, none, Str)
formula_list2string([F|Rest], Str) <=
    formula2string(F, none, FStr) &
    formula_list2string(Rest, RestStr) &
    Str = FStr ++ ",\n" ++ RestStr

rel formula2string (!formula,  !atom, ?string)
formula2string(~(A), _, Str) :: type(A, !atom) <=
        term2string(A, AS) & Str = "~"++AS
formula2string(~(A), _, Str)  :: true <=
    formula2string(A, none, AS) & Str = "~(" ++ AS ++ ")"

formula2string(and(P, Q), Op, Str) :: true <=
        formula2string(P, and, PStr) &    
        formula2string(Q, and, QStr) &
        join_formulas(Op, and, PStr, QStr, Str)
formula2string(or(P, Q), Op, Str) :: true <=    
        formula2string(P, or, PStr) &    
        formula2string(Q, or, QStr) &
        join_formulas(Op, or, PStr, QStr, Str)
formula2string(imp(imp(P1, Q1) , Q), Op, Str) :: true <=    
        formula2string(imp(P1, Q1), imp, PStr) &  
        formula2string(Q, imp, QStr) &
        join_formulas(Op, imp, "("++PStr++")", QStr, Str)
formula2string(imp(P, Q), Op, Str) :: true <=    
        formula2string(P, imp, PStr) &    
        formula2string(Q, imp, QStr) &
        join_formulas(Op, imp, PStr, QStr, Str)
formula2string(all(X, P), Op, Str) :: true <= 
        formula2string(P, all, PStr) &  
        term2string(X, XStr) &
        join_formulas(Op,  all, XStr, PStr, Str)
formula2string(ex(X, P), Op, Str) :: true <=
        formula2string(P, ex, PStr) &  
        term2string(X, XStr) &
        join_formulas(Op,  ex, XStr, PStr, Str)
formula2string(P, _, PredStr) :: type(P, !predicate) <=
        term2list(P, [F,..Args]) &
        type(Args, !list(formula_term)) &
        pred_args2str(Args, ArgsStr) &
        term2string(F, FStr) &
        PredStr = FStr ++ "(" ++ ArgsStr ++ ")"
formula2string(P, _, PStr) <=
    term2string(P, PStr)

rel join_formulas(atom, atom, string, string, ?string)
join_formulas(all, and, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " and " ++ QStr ++ ")"
join_formulas(ex, and, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " and " ++ QStr ++ ")"
join_formulas(_, and, PStr, QStr, Str) ::
    Str =  PStr ++ " and " ++ QStr
join_formulas(all, or, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " or " ++ QStr ++ ")"
join_formulas(ex, or, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " or " ++ QStr ++ ")"
join_formulas(and, or, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " or " ++ QStr ++ ")"
join_formulas(_, or, PStr, QStr, Str) ::
    Str =  PStr ++ " or " ++ QStr
join_formulas(all, imp, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " => " ++ QStr ++ ")"
join_formulas(ex, imp, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " => " ++ QStr ++ ")"
join_formulas(and, imp, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " => " ++ QStr ++ ")"
join_formulas(or, imp, PStr, QStr, Str) ::
    Str =  "(" ++ PStr ++ " => " ++ QStr ++ ")"
join_formulas(_, imp, PStr, QStr, Str) ::
    Str =  PStr ++ " => " ++ QStr
join_formulas(_, all, XStr, PStr, Str) ::
    Str =  " all "++  XStr ++ " " ++ PStr
join_formulas(_, ex, XStr, PStr, Str) ::
    Str =  " ex "++  XStr ++ " " ++ PStr


fun obvar_var(term, term) -> rel(??term, ??term)
obvar_var(X, V)(X, V) :: true
obvar_var(_, _)(A, A)

rel varstr2var(??term, ??term)
varstr2var(var(S), V) :: 
    type(S, string) & string2term(S, V)
% varstr2var(sk(N, Vars), Str) :: true <=
%         type(N, nat) & type(Vars, list(??term)) &
%         sort(Vars, SVars, @<) &
%         term2string(N, SN) &
%         skolem_vars2str(SVars, VarsStr) &
%         Str = "sk" ++ SN ++ VarsStr                       
varstr2var(X, X)


rel skolem_vars2str(list(??formula_term), ?string)
skolem_vars2str([], "") :: true
skolem_vars2str([V,..Vars], Str) <= 
    term2string(V, VStr) &
    skolem_vars2str_aux(Vars, Str1) &
    type(Str1, !string) &
    Str = "(" ++ VStr ++ Str1 ++ ")"

rel skolem_vars2str_aux(list(??formula_term), ?string)
skolem_vars2str_aux([], "") :: true
skolem_vars2str_aux([V,..Vars], Str) <=
    term2string(V, VStr) &
    skolem_vars2str_aux(Vars, VarsStr) &
    Str = "," ++ VStr ++ VarsStr



rel  strip_var(??term, ??term)
strip_var(var(X), R) :: type(X, !string) <= R = X
strip_var(X, X)

rel collect_vars(??term, ??term, ??term)
collect_vars(A,B,R) <= 
    type(A, !string) & string2term(A, V1) & var(V1) & R = [var(A)|B]


rel pred_args2str(!list(formula_term), ?string)

pred_args2str([A], AStr) ::
    parg2str(A, AStr)
pred_args2str([A,..Rest], Str) ::
    parg2str(A, AStr) &
    pred_args2str(Rest, RestStr) &
    Str = AStr ++ ", " ++ RestStr

rel parg2str(!formula_term, ?string)
parg2str(sk(N, []), Str) ::
    type(N, nat) & 
    term2string(N, SN) &
    Str = "sk" ++ SN                      
parg2str(sk(N, Vars), Str) ::
    type(N, nat) & 
    sort(Vars, SVars, @<) &
    type(SVars, !list(formula_term)) &
    pred_args2str(SVars, VarsStr) &
    term2string(N, SN) &
    %skolem_vars2str(SVars, VarsStr) &
    Str = "sk" ++ SN ++ "(" ++ VarsStr ++ ")"                       
parg2str(var(X), X) :: true
parg2str(A, AStr) <= term2string(A, AStr)



    