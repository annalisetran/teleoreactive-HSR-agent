%% Copyright 2017 Keith Clark, Peter Robinson
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permisions and
%% limitations under the License.



rel graph_path(First:NT,Last:?NT,Path:?list(NT),
               GraphR:rel(?NT,?NT),EndR:rel(?NT))
"Last is the last node of Path which is a shortest path of nodes
from First node to an EndR node where each adjacent pair satisfy the 
GraphR relation. The path must use at least one edge."
graph_path(First,Last,NdPath,GraphR,EndR) <=
    NewNodes = [NewNd :: GraphR(First,NewNd)] &
    bfs(NewNodes, [First], [], [], [First,..NewNodes], 
        NdPath, Last, GraphR, EndR) 


rel bfs(NewNodes:list(T), CurrentPath:list(T), NdsPaths:list(list(T)), 
        ExtendedNdsPaths:list(list(T)), Seen:list(T), NdPath:?list(T),
        Last:?T, GraphR:rel(?T,?T), EndR:rel(T))

%% No more adjacent nodes to process and no more current paths to process
%% In this case we extend the current paths to new paths that are extended
%% with nodes that are adjacent to the head node of a path.
%% We don't include any paths that would be extended with nodes that
%% already appear in some path
bfs([], _,  [], ExtendedNdPaths, Seen, NdPath, 
    Last, GraphR, EndR) <=
        ExtendedNdPaths = [Path,.. Rest] &
        Path = [N,..] &
        AdjNodes = [NewNd :: GraphR(N,NewNd) & not NewNd in Seen] &
        bfs(AdjNodes, Path, Rest, [], AdjNodes <> Seen,
            NdPath, Last, GraphR, EndR)
%% There are more paths to extend in the current round so extend the first 
%% of these
bfs([], _,  NdPaths, ExtendedNdPaths, Seen, NdPath, 
    Last, GraphR, EndR) <=
        NdPaths = [Path,.. RestNdPaths] &
        Path = [N,..] &
        AdjNodes = [NewNd :: GraphR(N,NewNd) & not NewNd in Seen] &
        bfs(AdjNodes, Path, RestNdPaths, ExtendedNdPaths,
            AdjNodes <> Seen, NdPath, Last, GraphR, EndR)
%% The next adjacent node of the current path being processed is an end node - 
%% return the reverse of this path
bfs([N,..], Path,  _NdPaths, _ExtendedNdPaths, _Seen, 
    NdPath, N, _GraphR, EndR) ::
    EndR(N) <= reverse([N,..Path], NdPath)
%% OW extend the current path with the node and add the updated path
%% to the list of paths to be processed in the next round
bfs([N,..Rest], Path,  NdPaths, ExtendedNdPaths, Seen, 
    NdPath, Last, GraphR, EndR) <=
    bfs(Rest, Path,  NdPaths, [[N,..Path],..ExtendedNdPaths], 
        Seen, NdPath, Last, GraphR, EndR)

/*
% for testing

rel adj(?nat, ?nat)

adj(1,2)
adj(1,3)
adj(2,4)
%adj(3,4)
adj(3,5)
adj(5,6)
adj(4,6)
adj(6,7)
adj(5,8)
adj(8,9)
%adj(4,10)
%adj(7,10)

rel symadj(?nat, ?nat)

symadj(A, B) <= adj(A, B)
symadj(A, B) <= adj(B, A)

fun end(nat) -> rel(?nat)

end(N)(M) <= N = M

%% graph_path(1, Last, Path, symadj, end(3))
*/