<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual is for QuLog/TeleoR (version 1.0, 21 February 2024).

Copyright (C) 2015 Peter Robinson, Keith Clark

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 -->
<title>Listing of Builtin Types (The QuLog/TeleoR 1.0 Reference Manual)</title>

<meta name="description" content="Listing of Builtin Types (The QuLog/TeleoR 1.0 Reference Manual)">
<meta name="keywords" content="Listing of Builtin Types (The QuLog/TeleoR 1.0 Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="QuLog-Index.html" rel="index" title="QuLog Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Listing-of-Builtin-Exceptions.html" rel="next" title="Listing of Builtin Exceptions">
<link href="Standard-Operators.html" rel="prev" title="Standard Operators">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="appendix" id="Listing-of-Builtin-Types">
<div class="header">
<p>
Next: <a href="Listing-of-Builtin-Exceptions.html" accesskey="n" rel="next">Listing of Builtin Exceptions</a>, Previous: <a href="Standard-Operators.html" accesskey="p" rel="prev">Standard Operators</a>, Up: <a href="index.html" accesskey="u" rel="up">QuLog/TeleoR</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="QuLog-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Listing-of-Builtin-Types-1"></span><h2 class="appendix">Appendix A Listing of Builtin Types</h2>
<p>Below is listed all the builtin type definitions and declarations as generated by the interpreter query <code>stypes</code>. The information is listed with type definitions first, type macros second, and type declarations third. Within each group the information is listed in alphabetic order.
</p>



<pre class="verbatim">def builtin_exception ::= read_term_syntax_error() |
    input_term_type_error(atom, string) | read_op_term_syntax_error(string) |
    input_term_error(atom, string) | string2term_syntax_error(string) |
    stream_not_writeable(string) | stream_not_readable(string) |
    stream_not_open(string) | prolog_call_type_error(string) |
    action_failure(string) | no_matching_action_rule(string) |
    no_matching_function_rule(string) | no_matching_tr_rule(tel_term) |
    arithmetic_function_domain_error(term) |
    remote_query_ontology_mismatch(string) |
    remote_query_exception(exception) | pedro_not_connected(atom) |
    pedro_name_already_registered(atom) | fork_thread_name_exists(atom) |
    qp_exception(string) | qulog2qp_type_exception(string) |
    no_agent_to_kill() | no_matching_task_to_kill(atom) |
    not_start_task_TR_procedure(string) | task_name_in_use(atom)
&quot;Constructor type for all qulog exception terms&quot;

def hand_shake_ ::= initialise_ | finalise_
&quot;Type of the pair of atom messages sent by a TeleoR agents to
a robotic interface to initiate and terminate control&quot;

def process_handle ::= atom @ atom

def remote_query_t_ ::= remote_query(string)
&quot;Type for remote queries - for internal use&quot;

def resource_info_ ::= res_(atom, list(resource))

def stream_enum_type_ ::= stdin | stdout | stderr

def stream_num_type_ ::= stream_(nat)

def thread_in_process ::= atom : agent_handle
&quot;Address format for communication to another thread of an
agent or QuLog process on same host&quot;

def thread_sizes_t ::= choice_size(nat) | env_size(nat) | heap_size(nat) |
    binding_trail_size(nat) | other_trail_size(nat) | scratchpad_size(nat) |
    name_table_size(nat) | ip_table_size(nat)
&quot;Sizes structures for specifying the sizes of data areas when forking.&quot;

def user_exception ::= default_exception_()

def write_type_nl__ ::= nl_
&quot;The atom that indicates a newline in argument list
of the write_list action&quot;

def write_type_other__ ::= sp_(int) | q_(string) | uq_(atom) | wr_(term)
&quot;The compound layout terms that can be used in argument
list of the write_list action&quot;

def agent_handle == atom || process_handle
&quot;Address formats for agents&quot;

def exception == builtin_exception || user_exception
&quot;The type for all exception terms including user exceptions. 
If the user doesn't define user_exception_ then the system declares it as
def user_exception ::= default_exception_().
This will be overwritten by a user declaration.&quot;

def handle == agent_handle || thread_handle
&quot;All the different address formats of a thread for communication&quot;

def robot_message == hand_shake_ || list(tel_action_term)
&quot;Union of hand_shake_ and robotic actions&quot;

def stream_type == stream_enum_type_ || stream_num_type_
&quot;Used for stream related actions eg open/close/read/write&quot;

def thread_handle == atom || thread_in_process
&quot;Address formats for threads&quot;

def write_type__ == write_type_nl__ || write_type_other__
&quot;The union type of all layout terms for use in  
argument list of the write_list action&quot;

fun #list(term) -&gt; nat,
    #set(term) -&gt; nat,
    #string -&gt; nat
&quot;Operator that returns the length of a list or string or the size of a set&quot;

fun $rel(int) -&gt; int,
    $rel(num) -&gt; num
&quot;Operator that returns numeric  value linked with an atom name&quot;

fun nat * nat -&gt; nat,
    int * int -&gt; int,
    num * num -&gt; num
&quot;Infix multiplication operator - left associative&quot;

fun nat ** nat -&gt; nat,
    int ** int -&gt; int,
    num ** num -&gt; num
&quot;Infix exponentiation operator - not associative&quot;

fun nat + nat -&gt; nat,
    int + int -&gt; int,
    num + num -&gt; num
&quot;Infix addition operator - left associative&quot;

fun string ++ string -&gt; string
&quot;Infix left associative operator which is both a function for 
concatenating a pair of strings and a pattern operator for use on
LHS of =? for non-deterministically splitting strings.&quot;

act !rel(?num) +:= !num,
    !rel(?int) +:= !int
&quot;Increment number associated with LHS atom by RHS value&quot;

fun int - int -&gt; int,
    num - num -&gt; num,
    -int -&gt; int,
    -num -&gt; num
&quot;Infix subtraction operator - left associative
and number complement prefix operator&quot;

act !rel(?num) -:= !num,
    !rel(?int) -:= !int
&quot;Decrement number associated with LHS atom by RHS value&quot;

fun num / num -&gt; num
&quot;Infix division operator - left associative
Note it always returns a floating point number
Use // for integer division returning an integer&quot;

fun //(nat, nat) -&gt; nat,
    //(int, int) -&gt; int
&quot;Infix integer division operator - left associative
Returns integer part of the division operation&quot;

fun /\(int, int) -&gt; int
&quot;Infix, integer bitwise AND operator - left associative&quot;

act !rel(?num) := !num,
    !rel(?int) := !int
&quot;Change number associated with LHS atom by RHS value&quot;

rel num &lt; num
&quot;Numeric values, less than&quot;

fun &lt;&lt;(int, int) -&gt; int
&quot;Shift bits of integer first arg. left by pos integer of second&quot;

fun list(T) &lt;&gt; list(T) -&gt; list(T)
&quot;Infix left associative operator which is both a function for appending 
a pair of complete lists and a pattern operator for use
on RHS of =? for non-deterministically splitting a list.&quot;

rel ??term = ??term
&quot;Any terms, unification with occurs check&quot;

rel num =&lt; num
&quot;Numeric values, less than or equal&quot;

rel ?T =@ !T,
    ??T =@ ??T
&quot;One sided unification&quot;

rel num &gt; num
&quot;Numeric values, greater than&quot;

rel num &gt;= num
&quot;Numeric values, greater than or equal&quot;

fun &gt;&gt;(int, int) -&gt; int
&quot;Shift bits of integer first arg. right by pos integer of second&quot;

rel ??term @&lt; ??term
&quot;QuLog term ordering, less than. 
Both arguments are left unchanged.&quot;

rel ??term @=&lt; ??term
&quot;QuLog term ordering, less than or equal. 
Both arguments are left unchanged.&quot;

rel ??term @&gt; ??term
&quot;QuLog term ordering, greater than. 
Both arguments are left unchanged.&quot;

rel ??term@ &gt;= ??term
&quot;QuLog term ordering, greater than or equal.
Both arguments are left unchanged.&quot;

fun \(int) -&gt; int
&quot;Prefix, returns integer that is the bitwise complement
of the argument integer&quot;

fun \/(int, int) -&gt; int
&quot;Infix integer bitwise OR operator - left associative&quot;

rel ??term \= ??term
&quot;Any terms, the negation of unification with occurs checkl. 
Both arguments are left unchanged.&quot;

fun abs(int) -&gt; nat,
    abs(num) -&gt; num
&quot;The absolute value of number arg.&quot;

fun acos(num) -&gt; num
&quot;Inverse cosine function&quot;

act actions(!robot_message)
&quot;Interpreter command that can be used in teleor mode when an agent
has been started using start_agent. It is followed by a list
of actions that agent wants the robotic interface to perform. 
The given actions must have been robotic actions.&quot;

rel allowed_act_call(??term)
&quot;Check that the argument is an allowed action call, i.e. it is a term
representing an action call with the correct modes and types. 
Typically used just before a call do(C). The argument is left unchanged.&quot;

rel allowed_dyn_call(??term)
&quot;Check that the argument is an allowed relation call to a dynamic relation. 
Typically used just before a call on forget. The argument is left unchanged.&quot;

rel allowed_rel_call(??term)
&quot;Check that the argument is an allowed relation call, i.e. it is a term
representing a relation call with the correct modes and types. 
Typically used just before a call call(C). The argument is left unchanged.&quot;

rel append(!list(T), !list(T), ?list(T)),
    append(?list(T), ?list(T), !list(T)),
    append(!list(??T), !list(??T), ?list(??T)),
    append(?list(??T), ?list(??T), !list(??T)),
    append(?list(??T), ??list(T), ??list(T))
&quot;Similar to the &lt;&gt; operator except it can be used
with non-ground lists and lists that have ,..Var undetermined tails&quot;

fun asin(num) -&gt; num
&quot;Inverse sine function&quot;

fun atan(num) -&gt; num
&quot;Inverse tangent function&quot;

fun atan2(Y : num, X : num) -&gt; num
&quot;The angle in radians between the
positive x-axis of a plane and the point  (X, Y).&quot;

rel between(Start : !int, End : !int, N : ?int)
&quot;Test or generate N such that Start =&lt; N =&lt; End&quot;

rel call(C : ??rel_term)
&quot;Call the relation term C. The type checker checks that C is callable as a
relation - i.e. it has a ground functor and the arguments have suitable types 
and modes.&quot;

fun ceiling(num) -&gt; int
&quot;The smallest integer greater than number arg.&quot;

act close(Stream : !stream_type)
&quot;Close the stream Stream&quot;

rel collect_simple_terms(rel(??term, ??term, ??term), ??term, ??term,
    ??term)
&quot;A lift of QuProlog's collect_simple_terms&quot;

act connect_to_pedro(Host : !atom default localhost,
    Port : !int default 4550)
&quot;Connect to the pedro server on Host using Port.&quot;

act control_device(!list(!tel_action_term), !list(tel_action_term))
&quot;User defined - required for embedded agents (only).
The arguments are the old actions and the new actions.&quot;

rel copy_term(Term : ??term, Copy : ??term)
&quot;Copy Term with all variables in Term replaced by fresh variables.
The first argument is left unchanged.&quot;

fun cos(num) -&gt; num
&quot;The cosine of radian value argument&quot;

rel delete(X : ?T, Xs : list(T), R : ?list(T))
&quot;R is Xs with X deleted.&quot;

act deregister_from_pedro()
&quot;Deregister process name with the Pedro server&quot;

fun set(T) diff set(T) -&gt; set(T)
&quot;Infix operator for finding elements of first set arg. not in the second.&quot;

act disconnect_from_pedro()
&quot;Disconnect from the Pedro server&quot;

act do(A : ??act_term)
&quot;Call the action term A. The type checker checks that A is callable as an
action - i.e. it has a ground functor and the arguments have suitable types 
and modes.&quot;

fun e() -&gt; num
&quot;The value of arithmentic constant 'e'&quot;

fun exec_time() -&gt; num
&quot;Returns lapsed time in secs since qulog process was forked.&quot;

act exit()
&quot;Exit this thread.&quot;

act exit_thread(!atom)
&quot;Exit thread with given name (if it exists).&quot;

rel false()
&quot;Relation call that always immediately fails.&quot;

fun filter(Test : rel(T1), List : list(T1)) -&gt; list(T1)
&quot;Filter the elements of List using Test&quot;

fun filter_map(Test : rel(T1), F : fun(T1) -&gt; T2,
    List : list(T1)) -&gt; list(T2)
&quot;Filter the elements of List using Test and then 
apply F to the filtered elements&quot;

fun floor(num) -&gt; int
&quot;The greatest integer less than the number arg.&quot;

act flush_output(Stream : !stream_type default stdout)
&quot;Flush Stream&quot;

act fork(Act : !act_term, Name : ?atom,
    Sizes : !list(!thread_sizes_t) default [])
&quot;Creates a new thread named Name executing
the action call Act. Name must be new thread name if given,
the sizes of the data areas are specified in Size.&quot;

act fork_light(Act : !act_term, Name : ?atom)
&quot;Same as fork except the sizes of the data areas are small&quot;

rel get_active_resources(?list(resource_info_))
&quot;Get the resources being used by the current running tasks as a list
of  resource_info_ terms where each term is of the form 
res_(TaskName, ResourceList) where each resource in ResourceList is
either a declared resource or all__ when no resources have been declared.&quot;

act get_line(Line : ?string, Stream : !stream_type default stdin)
&quot;Read Line from Stream&quot;

rel get_waiting_resources(?list(resource_info_))
&quot;Get the resources needed by the current waiting tasks as a list
of  resource_info_ terms where each term is of the form 
res_(TaskName, ResourceList) where each resource in ResourceList is
either a declared resource or all__ when no resources have been declared.&quot;

act handle_invalid_message(!string, !agent_handle)
&quot;System declared,
    user defined handler for invalid messages sent to a TR agent&quot;

act handle_message(!message, !agent_handle)
&quot;System declared, user defined handler for messages sent to a TR agent&quot;

act handle_robotic_actions()
&quot;User defined action for embedded agent to translate robotic actions&quot;

act handle_template_message(??message, !agent_handle)
&quot;System declared,
    user defined handler for template messages sent to a TR agent&quot;

act hash_table_insert(Table : !atom, Key : !atomic, Value : !term)
&quot;Insert the key-value pair Key, Value into the hash table with name Table&quot;

rel hash_table_lookup(Table : !atom, Key : !atomic, Value : ?term)
&quot;Lookup the value associated with the key Key in the hash table 
with name Table&quot;

act hash_table_remove(Table : !atom, Key : !atomic)
&quot;Remove the pair with key Key from the hash table Table&quot;

rel hash_table_search(Table : ?atom, Key : ?atomic, Value : ?term)
&quot;Search the hash tables for entries that match Table, Key, Value&quot;

rel ?T in !list(!T),
    ??T in !list(??T),
    ?T in !set(T),
    ?string in !string
&quot;Multi-purpose infix membership operator for retrieving or testing
membership of lists, sets and strings. For strings the first
argument is (or will be) a singleton string.&quot;

act init_message_handler()

act init_percept_handler()

fun set(T) inter set(T) -&gt; set(T)
&quot;Infix operator for finding intersection of two sets.&quot;

rel is_thread(Th : !atom)
&quot;Succeeds iff Th is the name of an existing thread.&quot;

rel isa(?term, !typeE(_))
&quot;Can be used to check or generate instances of the type
described by second argument providing this has a finite number of
ground instances.&quot;

act kill_agent()

act kill_task(!atom)

fun log(num) -&gt; num
&quot;The natural log value.&quot;

act log_list(!list(??term))
&quot;Display a list of terms to the TR logger with layout controlled 
using write_type_ descriptors. Term is left unchanged.&quot;

fun map(F : fun(T1) -&gt; T2, List : list(T1)) -&gt; list(T2)
&quot;Apply F to each element of List&quot;

fun max(nat, nat) -&gt; nat,
    max(int, int) -&gt; int,
    max(num, num) -&gt; num
&quot;The maximum of the two numbers&quot;

rel member(?T, !list(T)),
    member(??T, ??list(T))
&quot;Similar to the 'in' operator except the second argument
may be a list template, even an unbound variable.&quot;

fun min(nat, nat) -&gt; nat,
    min(int, int) -&gt; int,
    min(num, num) -&gt; num
&quot;The minimum of the two numbers&quot;

fun mod(M : int, N : int) -&gt; int
&quot;The remainder of integer division of M by N.
Can be used as infix operator.&quot;

fun now() -&gt; num
&quot;Returns Unix epoch time as a number of seconds&quot;

act open(FileName : !atom, RW : !atom, Stream : ?stream_type)
&quot;Open the file FileName in RW mode, matching Stream with generated stream&quot;

rel overlapping_resources(!list(resource), !list(resource))

act peek(?atom, Stream : !stream_type default stdin)
&quot;Peek at the next character (as an atom) in Stream. 
EOF is the empty atom ''&quot;

rel peek_messages(Msg : ??term, Addr : ?thread_handle,
    Timeout : !int default -1)
&quot;Search message buffer for Msg from Addr and fail if no match is found
within Timeout seconds (-1 means to block until message arrives)&quot;

fun pi() -&gt; num
&quot;The value of arithmentic constant 'pi'&quot;

act poll_sensors(?list(tel_percept_term))
&quot;User defined action for embedded agent percept collection&quot;

act post_process_percepts(!list(tel_percept_term), !list(tel_percept_term))
&quot;User defined action for post processing percepts&quot;

fun prod(list(int)) -&gt; int,
    prod(list(num)) -&gt; num
&quot;Returns product of nums or ints on list argument.&quot;

act put_line(Line : !string, Stream : !stream_type default stdout)
&quot;Write Line to Stream&quot;

act qmain(!list(string))
&quot;Entry point for qulog runtime system - same as main for prolog&quot;

act raise(Patt : !exception)
&quot;Raise Patt as an exception to be caught in some outer try-except&quot;

fun random_int(M : int, N : int) -&gt; int
&quot;A random integer between M and N inclusive.&quot;

fun random_num() -&gt; num
&quot;A random number between 0 and 1 inclusive.&quot;

act random_seed(S : ?nat)
&quot;S is the seed for the random number generator.&quot;

rel range(N : ?int, Start : !int, End : !int, Step : !int default 1)
&quot;Similar to Python range - Test or generate N such that 
Start =&lt; N &lt; End and N = Start + k*Step for some K in nat&quot;

rel re_match(RE : !string, String : !string, Match : ?list((nat, nat)))
&quot;RE is a regular expression, String is the string to match the RE against. 
If a match is found, Match is a list of 
pairs representing the start and end of matches.
On backtracking, Match is instantiated to the next list of matches.
re_match fails if RE is an invalid regular expression.&quot;

act read_op_term(??term, Stream : !stream_type default stdin)
&quot;Unifies its argument with the next term denoted by the next
sequence of characters in the stream followed by fullstop, return. The
read uses QuProlog level op declarations.&quot;

act read_term(??term, Stream : !stream_type default stdin)
&quot;Unifies its argument with the next term denoted by the next
sequence of characters in the stream followed by fullstop, return.&quot;

dyn received_message(term, agent_handle, num)
&quot;Used by the default message handler to store recieved messages.&quot;

act refresh_bs()
&quot;Used to enter a list of beliefs that replace the existing beliefs. 
Useful for debugging teleor programs as the user can check which TR procedure 
guards are true for a given state of the belief store.&quot;

act register_with_pedro(!atom)
&quot;Register process name with the Pedro server.
Deregister and reregister if already connected.&quot;

act remember_for(list(dyn_term), num)

rel remote_query_call(!handle)
&quot;A dummy declaration to be used with allowed_remote_query_from to 
allow remote queries from withing remote queries&quot;

rel resources(Task : ?atom, Resources : ?list(resource))
&quot;True if Task is a running task using Resources resources&quot;

act resources_hook()

act respond_remote_query(!string, !thread_handle)
&quot;Takes a query string from a client, parses it,
    type checks it and then calls
it - answer bindings, together with the query ID,
    are returned to the client&quot;

rel reverse(!list(T), ?list(T)),
    reverse(?list(T), !list(T)),
    reverse(!list(??T), ?list(??T)),
    reverse(?list(??T), !list(??T))
&quot;Can be used to reverse a complete list of template
terms.  Second argument can be list pattern using ,..&quot;

fun round(num) -&gt; int
&quot;The nearest integer to number argument.&quot;

rel running(Task : ?atom)
&quot;True if Task is a running task&quot;

rel same_agent_handle(!agent_handle, ?agent_handle)

rel same_thread_handle(!handle, ?handle)

act send_robotic_message(!robot_message)

act set_default_message_thread(!atom)
&quot;Changes the destination of messages sent to this agent/process without
a thread identification, to the thread named by the atom arg.&quot;

fun sin(num) -&gt; num
&quot;The sine of radian value argument&quot;

rel sort(!list(!T), ?list(T), !rel(!T, !T)),
    sort(!list(??T), ?list(??T), !rel(??T, ??T))
&quot;Will match the second argument against the first argument sorted by the
transitive order relation given as the third argument,
    without instantiating
variables in the first argument. 
If the relation is asymmetric, duplicate terms will be removed.&quot;

fun sqrt(num) -&gt; num
&quot;The square root of argument.&quot;

act start_agent(!agent_handle, atom)
&quot;Command that can be used only in teleor extension of qulog. 
First arg. is the handle of the robot interface or simulation with which 
the agent will interact, and the second argument
is the percepts update convention being used: all or updates.&quot;

act start_embedded_agent(!num)
&quot;Command that can be used only in teleor extension of qulog. 
The argument is the reactivity of the interface thread i.e. the 
time between percept collection events.&quot;

act start_named_task(TR : !tel_term, Name : !atom)
&quot;Start the TR procedure and give it the task name Name.&quot;

act start_task(TR : !tel_term, Name : ?atom, Root : !atom default task)
&quot;Start the TR procedure and give it the task name Name based on Root by 
extending Root with 1, 2, ... until an unused task name is found.&quot;

fun start_time() -&gt; num
&quot;Returns now() value when the qulog process was started.&quot;

fun str(term) -&gt; string
&quot;Return the string representation of the (ground) term.&quot;

rel string2term(String : !string, Term : ??term)
&quot;String is a string comprising the character sequence of a QuLog term. 
Term is unified with that term.&quot;

rel sub_string(String : !string, Start : ?nat, Length : ?int, After : ?nat,
    SubString : ?string)
&quot;Substring is the sub-string of String of length Length
starting at position Start. After is the number of characters
remaining in the string after Substring.&quot;

act subscribe(!string, ?nat)
&quot;Use the first arg as a string representing a Pedro subscription
and subscribe using that. The second argument is instantiated to 
the Id of the subscription.&quot;

fun sum(list(int)) -&gt; int,
    sum(list(num)) -&gt; num
&quot;The sum of nums or ints on list argument.&quot;

fun tan(num) -&gt; num
&quot;The tangent of radian value argument&quot;

rel task(?atom, ?tel_term)
&quot;Dynamic relation remembered by start_task and forgotten by kill_task.
Atom arg. is task name, term arg is term denoting the TeleoR procedure
 call it is executing.&quot;

rel template(??term)
&quot;Tests that its term argument is a compound term with non-variable
constructor. The argument is left unchanged.&quot;

rel term2list(!term, ?list(term)),
    term2list(?term, !list(term)),
    term2list(??term, ??list(term))
&quot;A lift of =.. where the call fails when a generated compound 
term is not of type term. If a function application is constructed 
then that application is evaluated.&quot;

rel term2string(Term : ??term, String : ?string)
&quot;Term is converted to String - the string representation of the term. 
Term is left unchanged.&quot;

rel this_agent_name(?atom)
&quot;Unifies it's argument with the name of this agent.&quot;

rel this_process_name(Name : ?atom)
&quot;The Pedro registered name of this process is Name.&quot;

rel this_task_name(?atom)
&quot;Unifies it's argument with the name of this task.&quot;

rel this_thread_name(Name : ?atom)
&quot;The name of thread executing the call is Name.&quot;

act thread_sleep(!num)
&quot;Causes the executing thread to suspend for given number of seconds.&quot;

rel time_(?num)
&quot;Dynamic belief maintained by default agent's percept and message handlers.
It always records the time of the most recent belief store update.&quot;

act Msg : ??term to Handle : !agent_handle
&quot;Message send action. Sends Msg to the  agent 
given by Handle.&quot;

act to_thread(??term, !thread_handle)

fun tolist(string) -&gt; list(string),
    tolist(set(T)) -&gt; list(T)
&quot;Converts a string or set to a list preserving order. For a string the 
result is the list of characters of the string as singleton strings.&quot;

fun toset(string) -&gt; set(string),
    toset(list(T)) -&gt; set(T)
&quot;Converts a string or list to a set. For a string the result
is the set of characters of the string as singleton strings.&quot;

rel transform_subterms(rel(??term, ??term), ??term, ??term)
&quot;A lift of QuProlog's transform_subterms. The call fails if 
the transformed term is not of type term.&quot;

rel true()
&quot;Relation call that always immediately succeeds.&quot;

rel type(??term, !typeE(T))
&quot;Can be used to check if a value has the type described by type 
the expression second argument. As a top level QuLog query 
can be used to find the type of a value. The first argument
is left unchanged.&quot;

fun set(T) union set(T) -&gt; set(T)
&quot;Infix operator for finding union of two sets.&quot;

act unsubscribe(ID : !nat)
&quot;If ID is the Pedro subscription of this process then that 
subscription will be removed.&quot;

rel var(??term)
&quot;Tests that its term argument is a variable. The argument is left unchanged.&quot;

rel waiting(Task : ?atom)
&quot;True if Task is a waiting task&quot;

rel writeDebug(!list(??term))
&quot;A relational version of write_list - meant to be only used for 
debugging purposes. Term is left unchanged.&quot;

act write_list(TermList : !list(??term),
    Stream : !stream_type default stdout)
&quot;Write TermList to Stream leaving TermList unchanged.&quot;

rel write_list_to_string(TermList : !list(??term), String : ?string)
&quot;Write TermList to string String leaving TermList unchanged.&quot;

act write_op_term(Term : ??term, Stream : !stream_type default stdout)
&quot;Write Term to Stream. The write uses QuProlog level op declarations. 
Term is left unchanged.&quot;
</pre>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Listing-of-Builtin-Exceptions.html">Listing of Builtin Exceptions</a>, Previous: <a href="Standard-Operators.html">Standard Operators</a>, Up: <a href="index.html">QuLog/TeleoR</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="QuLog-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
